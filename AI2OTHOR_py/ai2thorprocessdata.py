# -*- coding: utf-8 -*-
"""ai2thorprocessdata.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C92HBk44ESOwC2ego5DrGPysFcLh7FRA
"""

import random
import numpy as np
from tqdm import tqdm
import numpy.matlib as mat


class ProcessData:
    def __init__(self, filename):
        self.load_path = filename
        self.trainData = np.load(self.load_path, encoding='latin1', allow_pickle = True).tolist()
        self.num_dim = self.trainData[0].shape[1]
        self.TrainX = None
        self.TrainY = None

    def formatData(self, print_shapes):
        """remove all NoneTypes from training set"""
        self.trainData = [x for x in self.trainData if x is not None]
        p = 0
        for _ in range(0,  len(self.trainData)): p += len(self.trainData[_])
        reformated_trainData = np.zeros((p, self.num_dim))
        goals_trainData = np.zeros((p, self.num_dim))
        previous = np.zeros((p, self.num_dim))
        count = 0
        
        for i in tqdm(range(1, len(self.trainData))):
            target_length = len(self.trainData[i])
            reformated_trainData[count:count + target_length] = self.trainData[i]
            goals_trainData[count:count + target_length] = \
                mat.repmat(self.trainData[i][-1], target_length, 1)
            count += target_length

        TrainX = np.concatenate((reformated_trainData, goals_trainData), axis=1)
        TrainY = np.roll(reformated_trainData, -1, axis=0)
        # print(TrainX.shape)
        TrainX = TrainX[:-3]
        TrainY = TrainY[:-3]

        self.TrainY = np.expand_dims(TrainY, axis=1)
        self.TrainX = np.expand_dims(TrainX, axis=1)
        
        if print_shapes:
            print('TrainX shape: ', self.TrainX.shape)
            print('TrainY shape: ', self.TrainY.shape)
            # print('TrainX shape: ', self.TrainX[self.TrainX.shape[0]-10:self.TrainX.shape[0]])
            # print('TrainY shape: ', self.TrainY[self.TrainY.shape[0]-10:self.TrainY.shape[0]])
        return self.TrainX, self.TrainY

    def sampleBatches(self, batch_size):
        offset = random.randint(0, self.TrainY.shape[1]-batch_size)
        idx = np.arange(batch_size)
        return self.TrainX[:, idx + offset, :], self.TrainY[:, idx + offset, :]

#----------------------------------------------------------

class ProcessData_add:
    def __init__(self, filename):
        self.load_path = filename
        self.trainData = np.load(self.load_path, encoding='latin1', allow_pickle = True).tolist()
        self.num_dim = self.trainData[0].shape[1]
        self.TrainX = None
        self.TrainY = None

    def formatData(self, print_shapes,add_points =5):
        """remove all NoneTypes from training set"""
        self.trainData = [x for x in self.trainData if x is not None]
        p = 0
        #--------------------
        for _ in range(0,  len(self.trainData)): 
          p += (len(self.trainData[_]) -1)*add_points
        #----------------------
        reformated_trainData = np.zeros((p, self.num_dim))
        goals_trainData = np.zeros((p, self.num_dim))
        previous = np.zeros((p, self.num_dim))
        count = 0

     
        t = np.linspace(0,1,add_points)
        for i in tqdm(range(1, len(self.trainData))):
            length = len(self.trainData[i]) 
            # -----------------------------
            # t = np.linspace(0,1,10)
            path = self.trainData[i]
            path2 = []
            for j in range( length - 1 ):
              for k in t:
                # po = path[j+1]*i + (1-i)*path[j]
                path2.append( path[j+1]*k + (1-k)*path[j] )
                # print(po)
            path2 = np.array(path2)
            target_length = int(len(path2))
            reformated_trainData[count:count + target_length] = path2
            # ------------------------------
            # reformated_trainData[count:count + target_length] = self.trainData[i]
            goals_trainData[count:count + target_length] = \
                mat.repmat(self.trainData[i][-1], target_length, 1)
            count += target_length
            # print("done ",i," / ",count," \ t:",target_length," len:",length)

        TrainX = np.concatenate((reformated_trainData, goals_trainData), axis=1)
        TrainY = np.roll(reformated_trainData, -1, axis=0)
        cut_point = -3 *(add_points - 1)
        TrainX = TrainX[ : cut_point]
        TrainY = TrainY[ : cut_point]
        
        self.TrainY = np.expand_dims(TrainY, axis=1)
        self.TrainX = np.expand_dims(TrainX, axis=1)

        if print_shapes:
            print('TrainX shape: ', self.TrainX.shape)
            print('TrainY shape: ', self.TrainY.shape)
            # print('TrainX shape: ', self.TrainX[self.TrainX.shape[0]-10:self.TrainX.shape[0]])
            # print('TrainY shape: ', self.TrainY[self.TrainY.shape[0]-10:self.TrainY.shape[0]])
        return self.TrainX, self.TrainY

        

class ProcessData_step:
    def __init__(self, filename):
        self.load_path = filename
        self.trainData = np.load(self.load_path, encoding='latin1', allow_pickle = True).tolist()
        self.num_dim = self.trainData[0].shape[1]
        self.TrainX = None
        self.TrainY = None

    def formatData(self, print_shapes,dis_step = 10.):
        """remove all NoneTypes from training set"""
        self.trainData = [x for x in self.trainData if x is not None]
        p = 0
        L_paths = []
        for _ in range(0,  len(self.trainData)): 
          T = 0
          L=[]
          a = self.trainData[_]
          L.append(a[0])
          for i in range(len(self.trainData[_])-1):
            a1 = a[i]
            a2 = a[i+1]
            # print(a1,a2)
            # L.append(a1)
            dist = np.linalg.norm(a1-a2)
            # print(dist)
            t = int(dist/dis_step)
            # print(t)
            T += t

            # m = 1. / (t+1.)
            # print(m)
            points = np.linspace(0.,1.,t+2)
            # print(points)
            for j in points[1:]:
              point = a2*j + a1*(1.-j)
              # print(point)
              L.append(point)
          #--------------------
          L=np.array(L)
          L_paths.append(L)
          # for _ in range(0,  len(self.trainData)): 
          p += (len(self.trainData[_]) ) + T
        #----------------------
        reformated_trainData = np.zeros((p, self.num_dim))
        goals_trainData = np.zeros((p, self.num_dim))
        previous = np.zeros((p, self.num_dim))
        count = 0

        # L = []
     
        # t = np.linspace(0,1,add_points)
        for i in tqdm(range(0, len(self.trainData))):
            length = len(self.trainData[i]) 
            # -----------------------------
            # t = np.linspace(0,1,10)
            path = self.trainData[i]
            # path2 = []
            # for j in range( length - 1 ):
            #   for k in t:
            #     # po = path[j+1]*i + (1-i)*path[j]
            #     path2.append( path[j+1]*k + (1-k)*path[j] )
            #     # print(po)
            path2 = L_paths[i]
            # path2 = np.array(path2)
            target_length = int(len(path2))
            reformated_trainData[count:count + target_length] = path2
            # ------------------------------
            # reformated_trainData[count:count + target_length] = self.trainData[i]
            goals_trainData[count:count + target_length] = \
                mat.repmat(self.trainData[i][-1], target_length, 1)
            count += target_length
            # print("done ",i," / ",count," \ t:",target_length," len:",length)

        TrainX = np.concatenate((reformated_trainData, goals_trainData), axis=1)
        TrainY = np.roll(reformated_trainData, -1, axis=0)
        # cut_point = -3 *(add_points - 1)
        # TrainX = TrainX[ : cut_point]
        # TrainY = TrainY[ : cut_point]
        
        self.TrainY = np.expand_dims(TrainY, axis=1)
        self.TrainX = np.expand_dims(TrainX, axis=1)

        if print_shapes:
            print('TrainX shape: ', self.TrainX.shape)
            print('TrainY shape: ', self.TrainY.shape)
            # print('TrainX shape: ', self.TrainX[self.TrainX.shape[0]-10:self.TrainX.shape[0]])
            # print('TrainY shape: ', self.TrainY[self.TrainY.shape[0]-10:self.TrainY.shape[0]])
        return self.TrainX, self.TrainY