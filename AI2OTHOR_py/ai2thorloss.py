# -*- coding: utf-8 -*-
"""ai2thorloss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uULJQDWiELyTjDaLZyLGVMN3USd0ZLu7
"""

import numpy as np
import tensorflow as tf
import numpy.matlib as mat
from tqdm import tqdm
from tensorflow.python.ops import math_ops 
from tensorflow.python.framework import ops
from keras import backend as K
import matplotlib.path as mplPath
from matplotlib.patches import Polygon
from matplotlib.collections import PatchCollection
import matplotlib.pyplot as plt

def format_obstacles(load_poly):
    polygon = np.asarray(np.load(load_poly,allow_pickle=True))
    object_c = []
    for i in range(0,polygon.shape[0]):
        obj = mplPath.Path(polygon[i])

        object_c.append(obj)
      
    return object_c

def sides(obstacle_path):
  obs = []

  object_c = format_obstacles(load_poly=obstacle_path)

  for j in range(len(object_c)):
      for i in range(len(object_c[j])-1):
          obs.append([object_c[j].vertices[i],object_c[j].vertices[i+1]])
      obs.append([object_c[j].vertices[-1],object_c[j].vertices[0]])

  obs_side = tf.cast(obs,tf.float32)
  obs_side_A = obs_side[:,0,:]
  obs_side_B = obs_side[:,1,:]

  return obs_side_A, obs_side_B

def dotprod(a,b,c):
  return (c[:,:,0]-a[:,:,0])*(b[:,:,0]-a[:,:,0]) + (c[:,:,1]-a[:,:,1])*(b[:,:,1]-a[:,:,1])
  
def crossprod(a,b,c):
  return (c[:,:,1]-a[:,:,1])*(b[:,:,0]-a[:,:,0]) - (c[:,:,0]-a[:,:,0])*(b[:,:,1]-a[:,:,1])

def length(a,b):
  return (b[:,0]-a[:,0])*(b[:,0]-a[:,0]) + (b[:,1]-a[:,1])*(b[:,1]-a[:,1])

def check(a,b,c):
  eps = 0.00001
  dot_ba = dotprod(b,a,c)
  dot_ab = dotprod(a,b,c)
  cross_ba = crossprod(b,a,c)
  cross_ab = crossprod(a,b,c)

  # cond_ba = tf.keras.activations.relu((dot_ba - dot_ab) - eps)
  # cond_ab = tf.keras.activations.relu((dot_ab - dot_ba) - eps)

  cond_ba = dot_ba - dot_ab
  cond_ab = dot_ab - dot_ba

  cond_ba = tf.cast(cond_ba > 0,tf.float32)
  cond_ab = tf.cast(cond_ab > 0,tf.float32)

  l_dot = tf.zeros_like(dot_ab)
  ab_pos = dot_ab * cond_ab
  ba_pos = dot_ba * cond_ba

  l_dot = ab_pos + ba_pos

  #------------------------------------

  l_cross = tf.abs(cross_ab)

  cond1 = tf.cast(l_cross<0.05,tf.float32)
  cond2 = tf.cast(length(a[0],b[0]) >= l_dot, tf.float32)
  m = cond1 * cond2
  # m = tf.math.reduce_max(m,-1)
  
  return m

def T_func(u,v):
  vu = v[:,:,0] * u[:,:,0] + v[:,:,1] * u[:,:,1]
  vv = v[:,:,0] ** 2 + v[:,:,1] ** 2
  uu = u[:,:,0] ** 2 + u[:,:,1] ** 2
  return -1*vu/vv

def g_func(t,u,v):
  t= tf.cast(t,v.dtype)
  tt = t**2
  vu = v[:,:,0] * u[:,:,0] + v[:,:,1] * u[:,:,1]
  vv = v[:,:,0] ** 2 + v[:,:,1] ** 2
  uu = u[:,:,0] ** 2 + u[:,:,1] ** 2

  f = tt*vv + 2.0*t*vu + uu

  return tt*vv + 2.0*t*vu + uu

def p_func(t,A,B):
  t_mat = tf.repeat(tf.expand_dims(t,-1),2,-1)
  return (1-t_mat)*A + t_mat * B

def nearest_point_of_line1(A, B, C):
    
  v = B - A
  u = A - C

  t = T_func (u,v)

  M = p_func(t,A,B)

  check_points_M = check(A,B,M)

  check_points_M = tf.repeat(tf.expand_dims(check_points_M,-1),2,-1)
  cond_M = M * check_points_M

  dot_ba = dotprod(B,A,C)
  dot_ab = dotprod(A,B,C)

  cond_ba = dot_ba - dot_ab
  cond_ab = dot_ab - dot_ba

  cond_ba = tf.cast(cond_ba > 0,tf.float32)
  cond_ab = tf.cast(cond_ab > 0,tf.float32)

  cond_ba = tf.repeat(tf.expand_dims(cond_ba,-1),2,-1)
  cond_ab = tf.repeat(tf.expand_dims(cond_ab,-1),2,-1)


  cond_A = A * cond_ba
  cond_B = B * cond_ab


  cond_AB = (1 - check_points_M) * (cond_A + cond_B)

  return (cond_M + cond_AB)

def distmat_point(pred , obs): 
    pred = ops.convert_to_tensor_v2(pred)
    obs = math_ops.cast(obs, pred.dtype)
    data=len(pred)
    num_class = len(obs)

    obs2 = tf.transpose(obs)
    hh=(pred@obs2)

    g=tf.keras.backend.sum(tf.keras.backend.square(pred),axis=1,keepdims=True)

    q2 = tf.repeat(g , num_class,1)


    mm=tf.keras.backend.sum(tf.keras.backend.square(obs),axis=1,keepdims=True)
    m2 = tf.repeat(mm , data,1)
    DIST = tf.transpose(q2+tf.transpose(m2)-2*hh)

    return DIST

def find_nearest_point_obs1(nearest,new_points):
  d = tf.transpose(distmat_point(new_points[:,0,:],tf.reshape(nearest,(-1,nearest.shape[-1]))))
  dist = tf.reduce_min(d,-1)
  points = tf.gather_nd(tf.reshape(nearest,(-1,nearest.shape[-1])),tf.expand_dims(tf.argmin(d,-1),-1))

  return points, dist

def segment(obs_side_A,temp_p,obs_side_B):
  # p = obs_side_A
  # q = temp_p
  # r = obs_side_B

  c1 = tf.cast( temp_p[:,0:1] <= tf.reduce_max(tf.concat( (obs_side_A[:,0:1],obs_side_B[:,0:1] ) ,-1) , -1) , tf.float32 )

  c2 = tf.cast( temp_p[:,0:1] >= tf.reduce_min(tf.concat( (obs_side_A[:,0:1],obs_side_B[:,0:1]) ,-1) , -1) , tf.float32 )

  c3 = tf.cast( temp_p[:,1:] <= tf.reduce_max(tf.concat( (obs_side_A[:,1:],obs_side_B[:,1:]) ,-1) , -1) , tf.float32 )

  c4 = tf.cast( temp_p[:,1:] >= tf.reduce_min(tf.concat( (obs_side_A[:,1:],obs_side_B[:,1:]) ,-1) , -1) , tf.float32 )
  
  seg = (c1*c2*c3*c4)

  return seg

# segment(obs_side_A,temp_p,obs_side_B)

#orientation
def orientation(obs_A,temp,obs_B):
  # p = obs_side_A
  # q = temp_p
  # r = obs_side_B
  n= len(temp)
  print("n:",n)
  m = len(obs_A)
  print("m:",m)

  q1 = tf.repeat( temp[:,1:] ,m ,-1,)
  print("q1:",q1)
  q0 = tf.repeat( temp[:,0:1] ,m ,-1,)
  print("q0:",q0)


  p1 = tf.repeat( tf.transpose(obs_A[:,1:]) , n , 0 )
  p0 = tf.repeat( tf.transpose(obs_A[:,0:1]) , n , 0 )

  r1 = tf.repeat( tf.transpose(obs_B[:,1:]) , n , 0 )
  r0 = tf.repeat( tf.transpose(obs_B[:,0:1]) , n , 0 )

  o = ( ( q1 - p1 ) * (r0 - q0 ) ) - ( ( q0 - p0 )*( r1 - q1 ) )
  o_0 = tf.cast( o==0.0 ,tf.float32 )
  o_1 = tf.cast( o>0.0 ,tf.float32 )
  o_2 = tf.cast( o<0.0 ,tf.float32 )

  o_total = o_0 * 0.0  +  o_1 * 1.0  +  o_2 * 2.0
  return o_total

# orientation(obs_side_A,temp_p,obs_side_B)


def orientation_temp2(obs_A,temp,obs_B):

  n= len(temp)
  # print("n:",n)
  m = len(obs_A)
  # print("m:",m)

  q1 = tf.repeat( temp[:,1:] ,m ,-1,)
  # print("q1:",q1)
  q0 = tf.repeat( temp[:,0:1] ,m ,-1,)
  # print("q0:",q0)


  p1 = tf.repeat( tf.transpose(obs_A[:,1:]) , n , 0 )
  p0 = tf.repeat( tf.transpose(obs_A[:,0:1]) , n , 0 )
  # print("p0:",p0)


  r1 = tf.repeat( tf.transpose(obs_B[:,1:]) , n , 0 )
  r0 = tf.repeat( tf.transpose(obs_B[:,0:1]) , n , 0 )
  # print("r0:",r0)


  o = ( ( q1 - p1 ) * (r0 - q0 ) ) - ( ( q0 - p0 )*( r1 - q1 ) )
  o_0 = tf.cast( o==0.0 ,tf.float32 )
  o_1 = tf.cast( o>0.0 ,tf.float32 )
  o_2 = tf.cast( o<0.0 ,tf.float32 )

  o_total = o_0 * 0.0  +  o_1 * 1.0  +  o_2 * 2.0
  return o_total

# orientation_temp2(obs_side_A,temp_p,obs_side_B)


def orientation_temp1(temp,obs_A,obs_B):

  m= len(temp)
  # print("m:",m)
  n = len(obs_A)
  # print("n:",n)

  p1 = tf.repeat( temp[:,1:] ,n ,-1,)
  # print("p1:",p1)
  p0 = tf.repeat( temp[:,0:1] ,n ,-1,)
  # print("p0:",p0)


  q1 = tf.repeat( tf.transpose(obs_A[:,1:]) , m , 0 )
  q0 = tf.repeat( tf.transpose(obs_A[:,0:1]) , m , 0 )
  # print("q0:",q0)


  r1 = tf.repeat( tf.transpose(obs_B[:,1:]) , m , 0 )
  r0 = tf.repeat( tf.transpose(obs_B[:,0:1]) , m , 0 )
  # print("r0:",r0)


  o = ( ( q1 - p1 ) * (r0 - q0 ) ) - ( ( q0 - p0 )*( r1 - q1 ) )
  o_0 = tf.cast( o==0.0 ,tf.float32 )
  o_1 = tf.cast( o>0.0 ,tf.float32 )
  o_2 = tf.cast( o<0.0 ,tf.float32 )

  o_total = o_0 * 0.0  +  o_1 * 1.0  +  o_2 * 2.0
  return o_total

# orientation_temp1(temp_p,obs_side_A,obs_side_B)


def orientation_temp3(obs_A,obs_B,temp):

  m= len(temp)
  # print("m:",m)
  n = len(obs_A)
  # print("n:",n)

  p1 = tf.repeat( tf.transpose(obs_A[:,1:]) , m , 0 )
  p0 = tf.repeat( tf.transpose(obs_A[:,0:1]) , m , 0 )
  # print("p0:",p0)


  q1 = tf.repeat( tf.transpose(obs_B[:,1:]) , m , 0 )
  q0 = tf.repeat( tf.transpose(obs_B[:,0:1]) , m , 0 )
  # print("q0:",q0)


  r1 = tf.repeat( temp[:,1:] ,n ,-1,)
  r0 = tf.repeat( temp[:,0:1] ,n ,-1,)
  # print("r0:",r0)


  o = ( ( q1 - p1 ) * (r0 - q0 ) ) - ( ( q0 - p0 )*( r1 - q1 ) )
  o_0 = tf.cast( o==0.0 ,tf.float32 )
  o_1 = tf.cast( o>0.0 ,tf.float32 )
  o_2 = tf.cast( o<0.0 ,tf.float32 )

  o_total = o_0 * 0.0  +  o_1 * 1.0  +  o_2 * 2.0
  return o_total

# orientation_temp3(obs_side_A,obs_side_B,temp_p)


def orientation_temp12(temp1,temp2,obs_A):

  m= len(temp1)
  # print("m:",m)
  n = len(obs_A)
  # print("n:",n)

  p1 = tf.repeat( temp1[:,1:] ,n ,-1,)
  p0 = tf.repeat( temp1[:,0:1] ,n ,-1,)
  # print("p0:",p0)


  q1 = tf.repeat( temp2[:,1:] ,n ,-1,)
  q0 = tf.repeat( temp2[:,0:1] ,n ,-1,)
  # print("q0:",q0)


  r1 = tf.repeat( tf.transpose(obs_A[:,1:]) , m , 0 )
  r0 = tf.repeat( tf.transpose(obs_A[:,0:1]) , m , 0 )
  # print("r0:",r0)


  o = ( ( q1 - p1 ) * (r0 - q0 ) ) - ( ( q0 - p0 )*( r1 - q1 ) )
  o_0 = tf.cast( o==0.0 ,tf.float32 )
  o_1 = tf.cast( o>0.0 ,tf.float32 )
  o_2 = tf.cast( o<0.0 ,tf.float32 )

  o_total = o_0 * 0.0  +  o_1 * 1.0  +  o_2 * 2.0
  return o_total

def in_out(obs_side_A,obs_side_B,y_pred , right_end=1000. , down_end = 1000., side_corner_is_in = False):
  p1 = y_pred
  # print(y_pred)
  p2 = obs_side_A
  q2 = obs_side_B

  P1 = p1[:,1:]
  paddings = tf.constant([[0, 0,], [1, 0]])
  P1 = tf.pad(P1, paddings, "CONSTANT")

  P2 = p1[:,0:1] * 0. + right_end
  paddings = tf.constant([[0, 0,], [0, 1]])
  P2 = tf.pad(P2, paddings, "CONSTANT")

  q1 = P1+P2

  o1 = orientation_temp12(p1, q1, p2)
  o2 = orientation_temp12(p1, q1, q2)
  o3 = orientation_temp3(p2, q2, p1)
  o3_new = tf.cast(o3 == 0., tf.float32)
  o4 = orientation_temp3(p2, q2, q1)

  seg1 = segment(p1,p2,q1)
  seg2 = segment(p1,q2,q1)
  seg1 = tf.transpose(seg1)
  seg2 = tf.transpose(seg2)

  # seg1 = tf.reshape(seg1,(seg1.shape[1],seg1.shape[0]))
  # seg2 = tf.reshape(seg2,(seg2.shape[1],seg2.shape[0]))
  seg3 = segment(p2,p1,q2)
  seg4 = segment(p2,q1,q2)


  c = seg3 * o3_new
  cond_zero = tf.reduce_sum(c, 1)
  # cond_zero = cond_zero[:,0]

  side = tf.cast(cond_zero == 1., tf.float32)

  corner = tf.cast(cond_zero == 2., tf.float32)


  general = (tf.cast( o1 != o2 , tf.float32 )) * (tf.cast( o3 != o4 , tf.float32 ))
  special1 = (tf.cast( o1 == 0. , tf.float32 )) * (tf.cast( seg1 == 1. , tf.float32 ))
  special2 = (tf.cast( o2 == 0. , tf.float32 )) * (tf.cast( seg2 == 1. , tf.float32 ))
  special3 = (tf.cast( o3 == 0. , tf.float32 )) * (tf.cast( seg3 == 1. , tf.float32 ))
  special4 = (tf.cast( o4 == 0. , tf.float32 )) * (tf.cast( seg4 == 1. , tf.float32 ))
  
  # print("general",tf.reduce_sum(general) )
  # print("special1",tf.reduce_sum(special1) )
  # print("special2",tf.reduce_sum(special2) )
  # print("special3",tf.reduce_sum(special3) )
  # print("special4",tf.reduce_sum(special4) )



  cond_sp = special1 + special2 + special3 + special4

  extension = tf.cast( tf.reduce_sum( cond_sp , -1) != 0., tf.float32) * tf.cast(cond_zero == 0., tf.float32)
  # print("extension : ",extension)
  num_extensions = tf.reduce_sum( tf.cast( extension != 0, tf.float32)  )

  extension = tf.expand_dims(extension,1)
  extension = tf.repeat( extension , 2 ,-1)
  # print("extension : ",extension)

  # num_extensions = tf.reduce_sum( tf.cast( extension != 0, tf.float32)  )
  # print("ext_right :", num_extensions )

  # ==================================================


  noise = (np.random.random_integers(0,1)*2. - 1.) * np.random.uniform(0.0001 , 0.001 )
  noise = tf.cast( noise , tf.float32)

  y_pred = y_pred + tf.cast( extension != 0, tf.float32) * noise
  # print(y_pred)
  p1 = y_pred
  p2 = obs_side_A
  q2 = obs_side_B

  P1 = p1[:,1:]
  paddings = tf.constant([[0, 0,], [1, 0]])
  P1 = tf.pad(P1, paddings, "CONSTANT")

  P2 = p1[:,0:1] * 0. + right_end
  paddings = tf.constant([[0, 0,], [0, 1]])
  P2 = tf.pad(P2, paddings, "CONSTANT")

  q1 = P1+P2

  o1 = orientation_temp12(p1, q1, p2)
  o2 = orientation_temp12(p1, q1, q2)
  o3 = orientation_temp3(p2, q2, p1)
  o3_new = tf.cast(o3 == 0., tf.float32)
  o4 = orientation_temp3(p2, q2, q1)

  seg1 = segment(p1,p2,q1)
  seg2 = segment(p1,q2,q1)
  seg1 = tf.transpose(seg1)
  seg2 = tf.transpose(seg2)

  # seg1 = tf.reshape(seg1,(seg1.shape[1],seg1.shape[0]))
  # seg2 = tf.reshape(seg2,(seg2.shape[1],seg2.shape[0]))
  seg3 = segment(p2,p1,q2)
  seg4 = segment(p2,q1,q2)


  c = seg3 * o3_new
  cond_zero = tf.reduce_sum(c, 1)
  # cond_zero = cond_zero[:,0]

  side = tf.cast(cond_zero == 1., tf.float32)

  corner = tf.cast(cond_zero == 2., tf.float32)


  general = (tf.cast( o1 != o2 , tf.float32 )) * (tf.cast( o3 != o4 , tf.float32 ))
  special1 = (tf.cast( o1 == 0. , tf.float32 )) * (tf.cast( seg1 == 1. , tf.float32 ))
  special2 = (tf.cast( o2 == 0. , tf.float32 )) * (tf.cast( seg2 == 1. , tf.float32 ))
  special3 = (tf.cast( o3 == 0. , tf.float32 )) * (tf.cast( seg3 == 1. , tf.float32 ))
  special4 = (tf.cast( o4 == 0. , tf.float32 )) * (tf.cast( seg4 == 1. , tf.float32 ))
  
  # print("general",tf.reduce_sum(general) )
  # print("special1",tf.reduce_sum(special1) )
  # print("special2",tf.reduce_sum(special2) )
  # print("special3",tf.reduce_sum(special3) )
  # print("special4",tf.reduce_sum(special4) )



  cond_sp = special1 + special2 + special3 + special4

  extension = tf.cast( tf.reduce_sum( cond_sp , -1) != 0., tf.float32) * tf.cast(cond_zero == 0., tf.float32)
  # print("\nextension2 : ",extension)
  out = tf.cast( tf.reduce_sum( cond_sp , -1) == 0., tf.float32) *   tf.cast (tf.reduce_sum( general , -1 ) ,tf.float32)


  OUTs = tf.cast(out %2 == 0., tf.float32)  
  # print(OUTs.shape)
  INs = tf.cast(out %2 == 1., tf.float32) 

  num_corners = tf.reduce_sum( tf.cast( corner != 0, tf.float32)  ) 
  num_sides =  tf.reduce_sum( tf.cast( side != 0, tf.float32)  ) 
  num_extensions = tf.reduce_sum( tf.cast( extension != 0, tf.float32)  )
  num_OUTs = tf.reduce_sum( tf.cast( OUTs != 0, tf.float32) )
  num_INs =  tf.reduce_sum( tf.cast( INs != 0, tf.float32) )
  # print("ext_right2 :", num_extensions )


  if side_corner_is_in == False:
    # print("side_corner_is_in = false")
    condition_in = INs

  if side_corner_is_in == True:

    condition_in = INs + side + corner

  f_right = ((tf.cast( condition_in == 0, tf.float32) * 2.) - 1.)
  # print("\nright:", f_right)


  #-----------------------------------------------------------------------------------------------


  # return (f_right * f_down) if f_right != f_down else f_right
  return f_right

"""# mse_ner loss"""

def mse_ner(A, B, alpha= 100.0, pow_val = 20.):

  def loss(y_true, y_pred):


    new_points = y_true
    new_points = new_points[:,0,:]
    obs_side_A = A
    obs_side_B = B

    print("obsa", obs_side_A.shape )
    print("obsb", obs_side_B.shape )
    print( "ypred",y_pred[:,0,:].shape)

    io = in_out(obs_side_A,obs_side_B, y_pred[:,0,:])
    print("io", io.shape)


    print("y_true:",new_points.shape)
    print("obs:",obs_side_A.shape)
    new_points = tf.repeat(tf.expand_dims(new_points,1),len(obs_side_A),1)
    obs_side_A = tf.repeat(tf.expand_dims(obs_side_A,0),len(new_points),0)
    obs_side_B = tf.repeat(tf.expand_dims(obs_side_B,0),len(new_points),0)

    nearest = nearest_point_of_line1(obs_side_A,obs_side_B,new_points)
    y_obs, dist = find_nearest_point_obs1(nearest,new_points)

    dist_yp_yob = tf.reduce_sum( (y_pred[:,0,:] - y_obs)**2. , -1 ) 

    sqrt_dist = tf.math.sqrt(dist_yp_yob)

    l_exp_in =  pow_val - tf.math.pow( pow_val , (-1.0 * sqrt_dist + 1.) ) 


    inout_in = tf.cast(io == -1. , tf.float32) 
    inout_out = tf.cast(io == 1. , tf.float32) 

    L_IN = inout_in*l_exp_in

    eps = 0.001

    dist_yt_yob = tf.reduce_sum( (y_true[:,0,:] - y_obs)**2. , -1 ) 
    sqrt_dist_yt_yobs = tf.math.sqrt( dist_yt_yob )
    l_e = (tf.math.pow( pow_val , -1.* sqrt_dist_yt_yobs + 1. ))**2 / pow_val


    l_e_out = l_e *inout_out


    y_obs = tf.expand_dims(y_obs,axis=1)

    y_obs = tf.cast( y_obs , y_true.dtype )


    square = K.square(y_pred - y_true )
    square_obs = K.square(y_pred - y_obs )

    square = K.mean(square, axis=-1)
    square_obs = K.mean(square_obs, axis=-1)


    new_mse = square  +  L_IN * square - l_e_out *( square_obs + 1. ) + alpha



    new_mse = tf.keras.activations.relu(new_mse + eps)

    new_mse = K.mean(new_mse, axis=-1)


    new_mse = tf.expand_dims(new_mse, -1)


    return  new_mse 
  return loss
  
"""# mse loss"""

def mse(object_c):
  def loss(y_true, y_pred):
    global l
    l2 = 0.0
    square = K.square(y_pred - y_true )
    meansquare = K.mean(square, axis=-1)
    return  meansquare 
  return loss
  
  
  
