# -*- coding: utf-8 -*-
"""ai2thorcreatedata.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1McW_oePG9cNKONI2KIbp9X1RHhK2wDDz
"""

import numpy as np
import os
import matplotlib.path as mplPath
from matplotlib.patches import Polygon
import matplotlib.pyplot as plt
import random
import time
import ai2thorgeneratepatches as aigp
from google.colab import drive
drive.mount('/content/drive')

def format_obstacles(load_poly):
    polygon = np.asarray(np.load(load_poly,allow_pickle=True))
    object_c = []
    for i in range(0,polygon.shape[0]):
        obj = mplPath.Path(polygon[i])

        object_c.append(obj)
      
    return object_c

def check_intersect(A, B, object_c):
    t = np.linspace(0, 1, 100)
    t = np.delete(t,0)
    t = np.delete(t,-1)
    
    interp = np.asarray([B*i + (1-i)*A for i in t])
    decisions = [p.contains_points(interp) for p in object_c]
    decisions = [item for sublist in decisions for item in sublist]
    if any(decisions):
      return False
    else:
      return True # will return True if nodeA and nodeB are safely connectable

def reWire(nodes, l, object_c):
    q = 0
    for i in range(l-1,0,-1):
        l = len(nodes)
        k = 0
        p = nodes[i]
        for t in range(0,i-1):
          if check_intersect(np.array(p), np.array(nodes[t]), object_c):
            k+=1
            o = (i) - (t+1)
            for j in range(o):
                nodes.pop(t+1)
            # print("end")
            q += 1

          if k == 1:
            break

        if q == 1:
            break

    return nodes

def find_intersection( p0, p1, p2, p3 ) :

    s10_x = p1[0] - p0[0]
    s10_y = p1[1] - p0[1]
    s32_x = p3[0] - p2[0]
    s32_y = p3[1] - p2[1]

    denom = s10_x * s32_y - s32_x * s10_y

    if denom == 0 : return None # collinear
    denom_is_positive = denom > 0

    s02_x = p0[0] - p2[0]
    s02_y = p0[1] - p2[1]

    s_numer = s10_x * s02_y - s10_y * s02_x

    if (s_numer < 0) == denom_is_positive : return None # no collision
    t_numer = s32_x * s02_y - s32_y * s02_x

    if (t_numer < 0) == denom_is_positive : return None # no collision
    if (s_numer > denom) == denom_is_positive or (t_numer > denom) == denom_is_positive : return None # no collision


    # collision detected
    t = t_numer / denom
    intersection_point = [ p0[0] + (t * s10_x), p0[1] + (t * s10_y) ]

    return intersection_point

def distance(a,b):
    return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

def is_between(a,b,c):
    return (distance(a,c) + distance(c,b)) - distance(a,b) <= 0.1

def new_obs(obstacle_path):
  obs2 = []

  object_c = format_obstacles(load_poly=obstacle_path)

  for j in range(len(object_c)):
      for i in range(len(object_c[j])-1):
          obs2.append([object_c[j].vertices[i],object_c[j].vertices[i+1]])
      obs2.append([object_c[j].vertices[-1],object_c[j].vertices[0]])
  return obs2

def GB(obstacle_path,A,B,cx,cy):
  data = []
  hit_points = []
  data_goal = []
  intr = []
  corner = []

  T = time.time()

  data.append(A)
  hit_points.append(A)
  data_goal.append(B)

  s2g = 1
  A_S = A
  B_S = B

  print("start:",A)
  print("goal:",B)


  obs2 = new_obs(obstacle_path)
  if s2g == 1:
    # print("s2g")

    for i in range(len(obs2)):
      C = obs2[i][0]
      D = obs2[i][1]

      inter = find_intersection(A,B,C,D)

      if inter is not None:
        corner.append(obs2[i])

      intr.append(inter)


    hit = [x for x in intr if x is not None]

    for h in hit:
      hit_points.append(h)

    hit_points.append(B)


  dist_start = []

  for i in range(len(hit_points)):
    dist2 = np.sqrt( (hit_points[i][0] - hit_points[0][0])**2 + (hit_points[i][1] - hit_points[0][1])**2 )
    dist_start.append(dist2)

  hit_points = np.array(hit_points)[np.argsort(dist_start)].tolist()
  hit_points


  object_c = format_obstacles(load_poly=obstacle_path)
  object_c = object_c[:-1]

  hit_num= 0

  for j in range(len(hit_points)-1):
    if check_intersect(np.array(hit_points[j]),np.array(hit_points[j+1]),object_c) and j+1> hit_num :
      data.append(hit_points[j+1])
    if check_intersect(np.array(hit_points[j]),np.array(hit_points[j+1]),object_c) == False and j+1> hit_num :
      left = []
      right = []
      z=0
      side=[]
      for k in corner:
        if is_between(k[0],k[1],hit_points[j]):
          side.append(corner[z])
          break
        z = z+1

      obs = np.load(obstacle_path,allow_pickle=True)

      obs_pick = []
      for o in obs:
        pick = np.any(np.all(side[0][0] == np.array(o),-1))
        obs_pick.append(pick)


      obs_left = obs[np.argmax(obs_pick)]
      obs_right = obs[np.argmax(obs_pick)][::-1]

      side = side[0]


      arg_left = np.argmax(np.all(obs_left==side[1],-1))

      if isinstance(obs_left,list)==False:
        obs_left = obs_left.tolist()
      obs_left2 = obs_left[arg_left:]+obs_left[:arg_left]

      arg_right = np.argmax(np.all(obs_right==side[0],-1))

      if isinstance(obs_right,list)==False:
        obs_right = obs_right.tolist()
      obs_right2 = obs_right[arg_right:]+obs_right[:arg_right]
      obs_right2
      left.append(obs_left2[0])

      right.append(obs_right2[0])
      for q in range(len(obs_left2)-1):
        cond_hit_left=0
        cond_hit_right = 0
        check_left = 0
        check_right = 0


        for p_num,p in enumerate(hit_points):

          if is_between(obs_left2[q],obs_left2[q + 1],p )==True and p_num>j :
            cond_hit_left=1
            pp_left =p
            pp_left_num = p_num
          if is_between(obs_right2[q],obs_right2[q + 1],p )==True and p_num>j :
            cond_hit_right = 1
            pp_right = p
            pp_right_num = p_num


        if cond_hit_left==0:
          left.append(obs_left2[q + 1])
        if cond_hit_left==1:
          left.append(pp_left)
          check_left =1

        if cond_hit_right==0:
          right.append(obs_right2[q + 1])
        if cond_hit_right==1:
          right.append(pp_right)
          check_right =1
        
        if check_right*check_left == 1:

          if pp_left != pp_right:

            dist_left_goal = np.sqrt( (pp_left[0] - B[0])**2 + (pp_left[1] - B[1])**2 )
            dist_right_goal = np.sqrt( (pp_right[0] - B[0])**2 + (pp_right[1] - B[1])**2 )
            if dist_left_goal <= dist_right_goal:
              right = []
              hit_num= pp_left_num

            else:
              left = []
              hit_num= pp_right_num

            
          else:


            sorr_left =0.0
            sorr_right=0.0

            for s in range(len(left)-1):
              d=np.sqrt( (left[s][0] - left[s+1][0])**2 + (left[s][1] - left[s+1][1])**2 )
              sorr_left = sorr_left +d

            for s in range(len(right)-1):
              d=np.sqrt( (right[s][0] - right[s+1][0])**2 + (right[s][1] - right[s+1][1])**2 )
              sorr_right = sorr_right +d
            
            if sorr_left<= sorr_right:
              right = []
              hit_num= pp_left_num

            else:
              left = []  



          break
        else:
          if check_left ==1:
            right =[]
            hit_num= pp_left_num
            break

          if check_right ==1:
            hit_num= pp_right_num
            left=[]
            break


      if len(left) != 0 :
        dataplus =left
      else:
        dataplus= right

      data = data + dataplus

  return data

def create_GB_data(map_name,cx, cy,obstacle_path, samples_path, num_data, plot):

  Path = []
  Rewired_path = []

  k = 0
  T = []
  for i in range(num_data):
    samples = np.load(samples_path)

    idx0 = 0
    idx1 = 0

    while (idx0 == idx1):
      idx0 = random.randint(0, samples.shape[0]-1)
      idx1 = random.randint(0, samples.shape[0]-1)

    t = time.time()

    path = GB(obstacle_path, A=samples[idx0], B=samples[idx1],cx=350, cy=182)

    k+=1
    print(k)
    print("\n-------------------------\n")

    Path.append(np.array(path))

    object_c = format_obstacles(obstacle_path)

    a=b=0
    while True:
      a = len(path)
      path = reWire(path, len(path), object_c)
      b = len(path)
      if a == b:
        break

    T.append(time.time()-t)
    Rewired_path.append(np.array(path))

  print(time.time()-t)

  # plot a path
  i = random.randint(0, num_data-1)

  data = Path
  data_r = Rewired_path


  np.save(map_name+'_'+str(num_data)+'data.npy',  np.array(Rewired_path))


  if plot:
    aigp.generate_patches(cx, cy, obstacle_path)

    plt.plot( data[i][:, 0], data[i][:, 1] , marker ="o" , markersize = 5, color="k")
    plt.plot( data[i][0,0], data[i][0,1], 'g.', markersize = 5 )
    plt.plot( data[i][-1,0], data[i][-1,1], 'r.', markersize = 5 )


    print("\n-------------------------\n")
    print("Plot a sample before rewire")
    plt.show()


    aigp.generate_patches(cx, cy, obstacle_path)

    plt.plot( data_r[i][:, 0], data_r[i][:, 1] , marker ="o" , markersize = 5, color="k")
    plt.plot( data_r[i][0,0], data_r[i][0,1], 'g.', markersize = 5 )
    plt.plot( data_r[i][-1,0], data_r[i][-1,1], 'r.', markersize = 5 )

     
    print("Plot a sample after rewire")
    plt.show()

  return Path, Rewired_path